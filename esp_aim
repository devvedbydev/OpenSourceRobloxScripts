-- Configuration
local CONFIG = {
    ESPColor = Color3.fromRGB(173, 216, 230), -- Light blue by default
    TargetColor = Color3.fromRGB(255, 255, 255), -- White by default
    PredictionTime = 0.01, -- Default prediction time
    ESPEnabled = true, -- Default ESP enabled state
    TargetStrafe = false, -- Default target strafe state
    StrafeDistance = 6, -- Default strafe distance in studs
    StrafeSpeed = 5 -- Default strafe speed
}

-- Local Variables
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Chat = game:GetService("Chat")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

local targetPlayer = nil
local aiming = false -- Indicates if Q is currently toggled on (targeting)
local strafeEnabled = CONFIG.TargetStrafe -- Indicates if strafe is enabled
local strafeAngle = 0 -- Initial angle for strafing

-- Function to create or update a Highlight effect
local function updateHighlight(character, color)
    local highlight = character:FindFirstChild("Highlight")
    if not highlight then
        highlight = Instance.new("Highlight")
        highlight.Name = "Highlight"
        highlight.Adornee = character
        highlight.Parent = character
    end
    highlight.FillColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = color
    highlight.OutlineTransparency = 0.3
end

-- Function to remove the Highlight effect
local function removeHighlight(character)
    local highlight = character:FindFirstChild("Highlight")
    if highlight then
        highlight:Destroy()
    end
end

-- Function to find the closest player to the mouse cursor
local function getClosestPlayerToCursor()
    local mouse = LocalPlayer:GetMouse()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local characterPosition = character.HumanoidRootPart.Position
            local screenPosition, onScreen = Camera:WorldToScreenPoint(characterPosition)

            if onScreen then
                local mousePosition = Vector2.new(mouse.X, mouse.Y)
                local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mousePosition).Magnitude

                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

-- Function to predict the future position of a player
local function predictFuturePosition(character, predictionTime)
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        return Vector3.new(0, 0, 0)
    end

    local velocity = humanoidRootPart.Velocity
    local futurePosition = humanoidRootPart.Position + (velocity * predictionTime)
    return futurePosition
end

-- Function to handle aimlock and strafing logic
local function handleAimlockAndStrafe()
    if aiming and targetPlayer and targetPlayer.Character then
        local character = targetPlayer.Character
        local predictedPosition = predictFuturePosition(character, CONFIG.PredictionTime)

        -- Move camera to look at the target player
        Camera.CFrame = CFrame.new(Camera.CFrame.Position, predictedPosition)

        if strafeEnabled then
            -- Update strafing angle
            strafeAngle = (strafeAngle + CONFIG.StrafeSpeed * RunService.RenderStepped:Wait()) % 360

            local targetPosition = character.HumanoidRootPart.Position
            local characterPosition = HumanoidRootPart.Position
            local directionToTarget = (targetPosition - characterPosition).unit
            local rightVector = directionToTarget:Cross(Vector3.new(0, 1, 0)).unit
            local strafeOffset = rightVector * CONFIG.StrafeDistance

            -- Calculate new position for strafing
            local strafePosition = targetPosition + CFrame.Angles(0, math.rad(strafeAngle), 0):VectorToWorldSpace(strafeOffset)

            -- Move the local player around the target
            HumanoidRootPart.CFrame = CFrame.new(strafePosition, targetPosition)
        end
    end
end

-- Toggle aiming on/off with the Q key
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end

    if input.KeyCode == Enum.KeyCode.Q then
        aiming = not aiming
        if aiming then
            targetPlayer = getClosestPlayerToCursor()
            if targetPlayer then
                print("Aimlock enabled. Targeting: " .. targetPlayer.Name)
            else
                print("No target found.")
            end
        else
            targetPlayer = nil
            print("Aimlock disabled.")
        end
    end

    -- Toggle strafe on/off with the Z key
    if input.KeyCode == Enum.KeyCode.Z then
        strafeEnabled = not strafeEnabled
        if strafeEnabled then
            print("Target strafe enabled.")
        else
            print("Target strafe disabled.")
        end
    end

    -- Fully unlock with the X key
    if input.KeyCode == Enum.KeyCode.X then
        aiming = false
        strafeEnabled = false
        targetPlayer = nil
        print("Fully unlocked. Aimlock and strafe disabled.")
    end
end)

-- Function to handle chat commands
local function onChatMessage(message)
    if message:lower() == ".binds" then
        local bindsInfo = [[
Commands:
  Q - Toggle aimlock (lock on/off target)
  Z - Toggle target strafe (spin around the target)
  X - Fully unlock (disable aimlock and strafe)
]]
        -- Send binds information to the chat
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
            Chat:Chat(LocalPlayer.Character.Head, bindsInfo, Enum.ChatColor.Blue)
        end
    end
end

-- Monitor chat messages
LocalPlayer.Chatted:Connect(onChatMessage)

-- Update highlights and aimlock logic continuously
RunService.RenderStepped:Connect(function()
    if CONFIG.ESPEnabled then
        -- Update highlights for all players
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                if player == targetPlayer then
                    updateHighlight(player.Character, CONFIG.TargetColor) -- Target color
                else
                    updateHighlight(player.Character, CONFIG.ESPColor) -- ESP color
                end
            end
        end
    else
        -- Remove highlights if ESP is disabled
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                removeHighlight(player.Character)
            end
        end
    end

    -- Handle aimlock and strafing logic if enabled
    handleAimlockAndStrafe()
end)

-- Connect to PlayerAdded event to handle new players joining
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if CONFIG.ESPEnabled then
            updateHighlight(character, CONFIG.ESPColor) -- ESP color for new players if ESP is enabled
        end
    end)
end)

-- Optionally, if you want to keep updating as players leave or join
Players.PlayerRemoving:Connect(function(player)
    if player.Character then
        if CONFIG.ESPEnabled then
            removeHighlight(player.Character)
        end
    end
end)
